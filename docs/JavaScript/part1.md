# 第一部分 作用域和闭包

## 编译原理

:::tip 尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。 但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。
:::

### 传统编译语言编译过程

以JS语言举例

1. 分词/词法分析 这个过程会将书写的编程字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。 例如：var a = 2;。这段程序通常被分解为var、a、=、2、;。空格是否被当作词法单元取决于空格在语言中是否有意义。
   :::tip 关于分词和词法分析的区别

- 中文本书中原文的描述是：**如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析**。
- 通过查询资料本人的理解为：**词法分析是用来做分词的手段，词法分析的目的是分词**。
  :::

2. 解析/语法分析 这个过程将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(AST)
   抽象语法树类似一个对象，这个对象中存储了对分词的的描述。
3. 代码生成 将 AST 转换为可执行代码的过程被称为代码生成。

### JS编译

简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。

### 理解作用域

#### 概念

1. 引擎 从头到尾负责整个JS程序的编译及执行过程
2. 编译器 负责语法分析及代码生成
3. 作用域 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

#### 过程

以“var a = 2;”为例

1. 编译器过程
    1. 遇到var a，编译器会查询作用域中是否存在变量a，如果有则忽略，没有则创建一个变量，并命名为a。这个过程被称为LHS查询。即赋值操作的左侧查询。
    2. 为引擎生成运行时所需要的代码，这些代码用来处理a = 2这个赋值操作。
2. 引擎过程
    1. 引擎会查询作用域中是否有a这个变量，如果有就直接使用这个变量，如果没有则向上一层作用域中查询。这个过程被称为RHS查询。即赋值操作的非左侧查询。
    2. 如果最后引擎没有找到a这个变量，则会抛出一个异常
       :::tip LHS和RHS LHS的意思是试图找到变量的容器本身，从而可以进行复制，而RHS的目的更强调“取到他的源值”。

```javascript
console.log(a);

/**
 * 以这段代码为例
 * a 的引用是一个RHS引用，因为这里a 并没有被赋予给任何变量，
 * 而是需要取到a的值并将值传递给log方法。
 * 而对a = 2 这个a的引用则是LHS引用，
 * 因为实际上我们并不关心a的值是什么，我们只需要将2赋值给a
 */

// 举例
function foo(a) {
    console.log(a); // 2 
}

foo(2);
/**
 *  首先对于方法foo 需要先声明一个变量foo，并将function赋值给foo（LHS）。
 *  所以foo(2) 的执行则是找到foo所对应的方法（RHS）并执行。
 *  而方法中形参的赋值a = 2是隐式的所以这个是需要一次LHS查询的。
 */

```

结论：LHS 和 RHS 的含义是“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头 （RHS）”。
:::

#### 作用域嵌套

这一部分很好理解。就是当一个作用域中包含子作用域，那LHS和RHS在进行查询的时候，如果在当前作用域中没有查询到结果，会在外层嵌套作用域中继续查找。

## 词法作用域

### 词法阶段

词法作用域就是定义在词法阶段的作用域

```js
function foo(a) {
    var b = a * 2;
    function bar(c) {
        console.log(a, b, c);
    }
    bar(b * 3);
}

foo(2); // 2, 4, 12
```
在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含的气泡。

![1651217604(1)](./images/1651217604(1).jpg)
1. 包含着整个全局作用域，其中只有一个标识符：foo。
2. 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。
3. 包含着 bar 所创建的作用域，其中只有一个标识符：c。

:::tip 遮蔽效应
- 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作**遮蔽效应**
- 抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。
:::
::: 注
全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性。可以通过形如window.a的方式去查找变量，绕开遮蔽效应
:::

### 欺骗词法
eval方法和with方法。
eval会对js的性能产生影响，不建议使用。
另外一个不推荐使用 eval和with 的原因是会被严格模式所影响（限制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用
eval也被禁止了。

## 函数作用域和块作用域
### 函数中的作用域